#+TITLE: Emacs Configuration File
#+AUTHOR: yago
#+DESCRIPTION: An Org based Emacs configuration.
#+KEYWORDS: emacs, org, config, init.el
#+LANGUAGE: en
#+BABEL: :cache yes
#+PROPERTY: header-args :tangle yes


#+BEGIN_QUOTE
In the beginning...
#+END_QUOTE

* Loading/Library Search

  From Emacs' Info file, section =16.3 Library Search=:

  #+BEGIN_QUOTE
  When Emacs loads a Lisp library, it searches for the library in a list
  of directories specified by the variable ‘load-path’.

  ...
  When Emacs starts up, it sets up the value of ‘load-path’ in several
  steps.  First, it looks for the directory containing its own Lisp files,
  using default locations set when Emacs was compiled.

  ...
  If the environment variable ‘EMACSLOADPATH’ is set, it modifies the
  above initialization procedure.  Emacs initializes ‘load-path’ based on
  the value of the environment variable.

  The syntax of ‘EMACSLOADPATH’ is the same as used for ‘PATH’;
  directories are separated by ‘:’ (or ‘;’, on some operating
  systems).

  ...
  #+END_QUOTE

  This is important because we don't use a package manager for the
  chosen external libraries. We handle our dependencies by adding our
  =~/.emacs.d/lisp= directory (containing the external libraries) to
  Emacs' =load-path= using the =EMACSLOADPATH= environment variable.
  Therefore, the following snippet is present in our =.xinitrc= file:

  #+BEGIN_SRC sh

  export EMACSLOADPATH=~/.emacs.d/lisp:

  #+END_SRC

  Also, an important note on the syntax of this variable declaration:

  #+BEGIN_QUOTE
  An empty element in the value of the environment variable, whether
  trailing (as in the above example, note the trailing ‘:’), leading, or
  embedded, is replaced by the default value of ‘load-path’ as determined
  by the standard initialization procedure.  If there are no such empty
  elements, then ‘EMACSLOADPATH’ specifies the entire ‘load-path’.
  #+END_QUOTE

  So don't forget the ":" in the end of the environment variable
  declaration.

  Finally, there's the need of a =subdirs.el= file to tell Emacs to
  recursively add all directories inside of our custom =load-path=
  entry to the =load-path= itself.

  #+BEGIN_QUOTE
  For each directory in ‘load-path’, Emacs then checks to see if it
  contains a file ‘subdirs.el’, and if so, loads it.  The ‘subdirs.el’
  file is created when Emacs is built/installed, and contains code that
  causes Emacs to add any subdirectories of those directories to
  ‘load-path’.
  #+END_QUOTE

  And such code contained in the =subdirs.el= file is:

  #+BEGIN_SRC emacs-lisp :tangle no

  (if (fboundp 'normal-top-level-add-subdirs-to-load-path)
      (normal-top-level-add-subdirs-to-load-path))

  #+END_SRC

  /NOTE: One can also read more about Emacs' startup at the Info/
  /section "Startup Summary"./
  /Refer to: =C-h= =i= =g= (elisp)Startup Summary RET/

  The use of a "custom load-path directory" is tied to the use of the
  =autload= funcionality described in the next section.

* Autoload

  #+BEGIN_QUOTE
  The “autoload” facility lets you register the existence of a function or
  macro, but put off loading the file that defines it. The first call
  to the function automatically loads the proper library,
  ...
  #+END_QUOTE

  A common problem with other Emacs configurations is a =very slow
  startup=. By using the =autoload= facility, we can avoid loading
  unecessary information onto memory before it's actually needed.

  For this to work, we need a =loaddefs= file generated by some
  function like =loaddefs-generate= (the most up to date option
  today, February 2nd, 2024).

  There's the =loaddefs= file generated by Emacs itself for its own
  Lisp files, so let's load those symbol's:

  #+BEGIN_SRC emacs-lisp

  (require 'loaddefs)

  #+END_SRC

  We now need our custom libraries' symbols. So we'll generate a
  =lisp-loaddefs.el= file inside our =load-path= entry, i.e., inside
  of =~/.emacs.d/lisp=.

  To generate this file we'll need a function that:
  1. Goes through every sub-directory in our target directory;
  2. Calls the =loaddefs-generate= function for that dir to collect
     all definitions marked with the magic =;;;###autoload= comment;
  3. Add those symbols to our =lisp-loaddefs.el=.


  As an extra credit, our function will allow =interactive= calls, in
  which case the =lisp=loaddefs.el= file will be entirely
  "regenerated".

  #+BEGIN_SRC emacs-lisp

  (require 'cl-seq)

  (defun seconf/generate-loaddefs (&optional generate-full)
    "Generate loaddefs file for all directories inside of `user-emacs-directory/lisp'.
  If called interactively, regenerate all loaddefs."
    (interactive "p")
    (let ((dir (expand-file-name "lisp/" user-emacs-directory))
          (outputfile "lisp-loaddefs.el"))
      (loaddefs-generate
       (cl-remove-if-not #'file-directory-p (directory-files-recursively dir "^[^.]" t))
       (expand-file-name outputfile dir) nil nil nil generate-full)
      (when generate-full
        (message "Fully generated new lisp-loaddefs.el file"))))

  #+END_SRC

  We can now add this function call to an early hook to ensure we
  create or update our =lisp-loaddefs.el= file as we start a session.

  #+BEGIN_SRC emacs-lisp

  (add-hook 'window-setup-hook
            (lambda ()
              (seconf/generate-loaddefs)))

  #+END_SRC

  Finally, we can load our symbols onto memory, by calling =require=
  (and telling it not break in case the file is not found).

  #+BEGIN_SRC emacs-lisp

  (require 'lisp-loaddefs nil t)
  ;; (setq load-prefer-newer noninteractive)

  #+END_SRC

* History and Cache

  For many functionalities that go through the minibuffer, having a
  list of =previously used candidates= depends on having a set
  =history variable= (that can also be viewed as a cached list of
  candidates). Among these variables we have things such as:
  =extended-command-history=, =file-name-history=,
  =minibuffer-history=, =buffer-name-history=,
  =shell-command-history= and many others.

  Needles to say, this is a "must have" feature to be enabled.

  Therefore, we can use =savehist= to populate these variables and
  additionally persist this "history" in a file.

  The target directory here is going to be called =cache= in lack of
  a better name.

  Hence, our code here is going to:

  1. "Create if it doesn't exist" the =~/.emacs.d/cache= directory;
  2. Configure some settings from =savehist=;
  3. Enable =savehist mode=.


  #+BEGIN_SRC emacs-lisp

  (let ((cache-dir (expand-file-name "cache/" user-emacs-directory)))
    (unless (file-exists-p cache-dir)
      (make-directory cache-dir)))

  #+END_SRC

  Now, configure =savehist=:

  #+BEGIN_SRC emacs-lisp

  ;; file name where minibuffer history is saved to and loaded from.
  (customize-set-variable
   'savehist-file (concat user-emacs-directory "cache/history"))

  ;; if non-nil, save all recorded minibuffer histories.
  (customize-set-variable 'savehist-save-minibuffer-history t)

  ;; maximum length of history lists before truncation takes place
  (customize-set-variable 'history-length 1024)

  #+END_SRC

  And finally, enable =savehist mode=:

  #+BEGIN_SRC emacs-lisp

  ;; enable savehist mode
  (add-hook 'window-setup-hook
            (lambda ()
              (funcall 'savehist-mode 1)))

  #+END_SRC

* Grab bag of system-wide configurations

  Here are some very useful general purpose variables being set,
  keybinds being defined, aliases, etc.

  This yes-or-no alias is so good for quickly answering minibuffer
  prompts.

  #+BEGIN_SRC emacs-lisp

  ;; yes or no
  (defalias 'yes-or-no-p 'y-or-n-p)

  #+END_SRC

  #+BEGIN_SRC emacs-lisp

  ;; column number display in the mode line
  (add-hook 'window-setup-hook
            (funcall 'column-number-mode 1))

  ;; buffer size display in the mode line
  (add-hook 'window-setup-hook
            (funcall 'size-indication-mode 1))

  #+END_SRC

  #+BEGIN_QUOTE
  Toggle line highlighting in all buffers (Global Hl-Line mode).
  #+END_QUOTE

  #+BEGIN_SRC emacs-lisp

  ;; enable highlight line
  (add-hook 'window-setup-hook
            (funcall 'global-hl-line-mode))

  #+END_SRC

  Configure/set coding-system (UTF8) everywhere.

  #+BEGIN_SRC emacs-lisp

  ;; coding system to use with system messages
  (customize-set-variable 'locale-coding-system 'utf-8)

  ;; coding system to be used for encoding the buffer contents on saving
  (customize-set-variable 'buffer-file-coding-system 'utf-8)

  ;; add coding-system at the front of the priority list for automatic detection
  (prefer-coding-system 'utf-8)

  ;; set coding system (UFT8)
  (set-language-environment "UTF-8")
  (set-terminal-coding-system 'utf-8)
  (set-keyboard-coding-system 'utf-8)
  (set-selection-coding-system 'utf-8)

  #+END_SRC

  Disable ugly startup screen:

  #+BEGIN_SRC emacs-lisp

  ;; non-nil inhibits the startup screen
  ;; this variable is an alias for `inhibit-startup-screen'
  (customize-set-variable 'inhibit-startup-message t)

  ;; non-nil inhibits the initial startup echo area message
  (customize-set-variable 'inhibit-startup-echo-area-message nil)

  #+END_SRC

  Focus =help buffer=:

  #+BEGIN_SRC emacs-lisp

  ;; always select the help window
  (customize-set-variable 'help-window-select t)

  #+END_SRC

  Enable use of =C-j= as =Enter= in =help-mode=:

  #+BEGIN_SRC emacs-lisp

  (eval-after-load 'help-mode
    (lambda ()
      (when (boundp 'help-mode-map)
        (define-key help-mode-map (kbd "C-j") 'push-button))))

  #+END_SRC

* Dealing with Directories (dired)

  =dired= is the main tool for dealing with directories inside Emacs.
  Here are some really minor tweaks for an improved usage.

  Avoid creating a bunch of buffers from the directories accessed from
  =dired=:

  #+BEGIN_SRC emacs-lisp

  ;; enable dired-find-alternate-file
  (add-hook 'window-setup-hook
            (lambda ()
              (put 'dired-find-alternate-file 'disabled nil)))

  #+END_SRC

  And add some key-binds to improve usability:

  #+BEGIN_SRC emacs-lisp

  ;; dired-mode-map
  (eval-after-load 'dired
    (lambda ()
      (when (boundp 'dired-mode-map)
        (define-key dired-mode-map (kbd "RET") 'dired-find-alternate-file)
        (define-key dired-mode-map (kbd "C-j") 'dired-find-alternate-file))))

  #+END_SRC

* Dealing with Buffers

  This is a large (and probably chaotic) section for everything we
  consider to be "dealing with buffers". Hence, there might be some
  functions and variables mentioned here that are =technically=
  "dealing with windows", however, since the "side effects feel like"
  they're being applied to the buffer being displayed, we'll keep
  these functions and variables here.

** Managing Buffers

   #+BEGIN_SRC emacs-lisp

   ;; kill buffer and window
   (define-key ctl-x-map (kbd "C-k") 'kill-buffer-and-window)

   ;; keyboard quit. might remove this. not sure if really used.
   (global-set-key (kbd "M-ESC") 'keyboard-escape-quit)

   #+END_SRC

   These next key binds/lambdas are technically related to frames,
   however, the goal and side effect here are to quickly (and
   globally) increase/decrease font size, so we'll leave it here in
   "Managing Buffers".

   #+BEGIN_SRC emacs-lisp

   ;; handy binds for quickly increasing/decreasing font size
   ;; while taking into account i3wm keybinds.
   (global-set-key (kbd "s-+")
                   (lambda ()
                     (interactive)
                     (let ((old-face-attribute (face-attribute 'default :height)))
                       (set-face-attribute 'default nil :height (+ old-face-attribute 10)))))

   (global-set-key (kbd "s-=")
                   (lambda ()
                     (interactive)
                     (let ((old-face-attribute (face-attribute 'default :height)))
                       (set-face-attribute 'default nil :height (- old-face-attribute 10)))))

   #+END_SRC

** Editing Buffers

   Here's a bunch of handy functions and binds to use when editing
   buffers:

   #+BEGIN_SRC emacs-lisp

   ;; line movement
   (global-set-key (kbd "C-a") 'handy-buffer/back-to-indent-or-line) ;; handy-buffer.el
   (global-set-key (kbd "C-e") 'move-end-of-line)

   ;; copy/paste
   (global-set-key (kbd "M-y") 'browse-kill-ring) ;; browse-kill-ring.el

   ;; indentation
   (global-set-key (kbd "M-i") 'handy-buffer/indent-region-or-buffer) ;; handy-buffer.el

   ;; line manipulation
   (global-set-key (kbd "M-j") 'handy-buffer/duplicate-line-or-region) ;; handy-buffer.el
   (global-set-key (kbd "M-p") 'handy-buffer/transpose-lines-up) ;; handy-buffer.el
   (global-set-key (kbd "M-n") 'handy-buffer/transpose-lines-down) ;; handy-buffer.el

   ;; word/region manipulation
   (global-set-key (kbd "M-l") 'downcase-word)
   (global-set-key (kbd "C-w") 'handy-buffer/kill-region-or-backward-word) ;; handy-buffer.el

   #+END_SRC

   And some needed settings for =tabs= and =indentation=:

   #+BEGIN_SRC emacs-lisp

   ;; indentation can insert tabs if this is non-nil
   (customize-set-variable 'indent-tabs-mode nil)

   ;; default number of columns for margin-changing functions to indent
   (customize-set-variable 'standard-indent 4)

   ;; distance between tab stops (for display of tab characters), in columns.
   (customize-set-variable 'tab-width 4)

   ;; if 'complete, TAB first tries to indent the current line
   ;; if t, hitting TAB always just indents the current line
   ;; If nil, hitting TAB indents the current line if point is at the left margin
   ;; or in the line's indentation
   (customize-set-variable 'tab-always-indent 'complete)

   #+END_SRC

*** Whitespace

    #+BEGIN_QUOTE
    This package is a minor mode to visualize and clean
    blanks (TAB, (HARD) SPACE and NEWLINE).
    #+END_QUOTE

    This is really useful in keeping files clean from "blank" lines
    containing only spaces or tabs, which is the reason for this hook
    entry:

    #+BEGIN_SRC emacs-lisp

    ;; clean whitespace and newlines before buffer save
    (add-hook 'before-save-hook #'whitespace-cleanup)

    #+END_SRC

    #+BEGIN_SRC emacs-lisp

    ;; specify which kind of blank is visualized
    ;; empty was removed
    (customize-set-variable
     'whitespace-style
     '(face
       tabs spaces trailing lines
       space-before-tab newline indentation
       space-after-tab space-mark tab-mark
       newline-mark missing-newline-at-eof))

    #+END_SRC

*** Delsel

    This package makes it possible to replace or delete the
    active/selected region, which is a popular behavior in personal
    computer text editors.

    #+BEGIN_SRC emacs-lisp

    ;; delete selection-mode
    (add-hook 'window-setup-hook
              (lambda ()
                (funcall 'delete-selection-mode 1)))

    #+END_SRC

*** Comments (newcomment)

    This library contains functions and variables for commenting and
    uncommenting source code.

    #+BEGIN_SRC emacs-lisp

    ;; global-map
    (global-set-key (kbd "M-c") 'comment-or-uncomment-region)

    #+END_SRC

** Navigating through Buffers

   Here are some general purpose binds/commands for navigating through
   buffers.

   #+BEGIN_SRC emacs-lisp

   ;; next and previous buffer (on current window)
   (define-key ctl-x-map (kbd "C-,") 'previous-buffer)
   (define-key ctl-x-map (kbd "C-.") 'next-buffer)

   #+END_SRC

   The following are specific libraries/subsections related to buffer
   navigation.

*** Ibuffer

    Ibuffer is a major mode for viewing buffers arranged as a list.
    This lib provides a convenient way of performing many operations
    on opened buffers as well as many ways of manipulating the
    arranged list, i.e., filtering subsets of list elements,
    aggregating related buffers, etc.

    #+BEGIN_SRC emacs-lisp

    ;; the criteria by which to sort the buffers
    (customize-set-variable 'ibuffer-default-sorting-mode 'filename/process)

    ;; if non-nil, display the current Ibuffer buffer itself
    (customize-set-variable 'ibuffer-view-ibuffer nil)

    ;; if non-nil, then show the names of filter groups which are empty
    (customize-set-variable 'ibuffer-show-empty-filter-groups nil)

    #+END_SRC

    As mentioned, Ibuffer accepts an association list as instruction
    on how to filter/separate displayed opened buffers.

    #+BEGIN_SRC emacs-lisp

    (customize-set-variable
     'ibuffer-saved-filter-groups
     (quote (("default"
              ("Emacs" (or
                        (name . "^\\*eldoc for")
                        (name . "^\\*scratch\\*$")
                        (name . "^\\*Warnings\\*$")
                        (name . "^\\*Completions\\*$")
                        (name . "^\\*Completions\\*$")
                        (name . "^\\*Messages\\*$")))

              ("Comint" (or
                         (mode . comint-mode)
                         (name . "^\\*dashboard\\*$")
                         (name . "^\\*tramp")
                         (name . "^\\*make\\*$")))

              ("Custom" (mode . Custom-mode))

              ("Info"  (or
                        (mode . Info-mode)
                        (mode . dictionary-mode)
                        (mode . help-mode)
                        (mode . apropos-mode)
                        (mode . Man-mode)))

              ("Tags" (or
                       (mode . tags-table-mode)
                       (mode . xref--xref-buffer-mode)))

              ("Compilation" (or
                              (mode . compilation-mode)
                              (mode . emacs-lisp-compilation-mode)
                              (name . "^\\*compilation\\*$")))

              ("Debug"  (or (mode . debugger-mode)
                            (name . "^\\*debug")))

              ("Org" (or (mode . org-mode)
                         (name . "\\.org")))

              ("Grep" (or
                       (mode . ag-mode)
                       (mode . occur-mode)))

              ("Term" (mode . term-mode))
              ("Shell" (or
                        (mode . shell-mode)
                        (mode . eshell-mode)))

              ("Eww" (mode . eww-mode))
              ("Dired" (mode . dired-mode))

              ("Magit" (or
                        (mode . magit-mode)
                        (mode . magit-status-mode)
                        (mode . magit-diff-mode)
                        (mode . magit-process-mode)))))))

    #+END_SRC

    Now, let's add a some calls to =ibuffer-mode-hook= to tell it how
    to behave upon its entry:

    #+BEGIN_SRC emacs-lisp

    ;; hook run upon entry into `ibuffer-mode'
    (add-hook 'ibuffer-mode-hook
              (lambda ()
                (ibuffer-auto-mode 1)
                (ibuffer-switch-to-saved-filter-groups "default")))

    #+END_SRC

    And, ~finally~, let's add a key bind so we can quickly call it:

    #+BEGIN_SRC emacs-lisp

    (define-key ctl-x-map (kbd "C-b") 'ibuffer)

    #+END_SRC

** Navigating inside Buffers

   #+BEGIN_SRC emacs-lisp

   ;; scroll movement
   (global-set-key (kbd "C-M-v") 'scroll-other-window)
   (global-set-key (kbd "C-M-y") 'scroll-other-window-down)

   ;; search
   (global-set-key (kbd "M-s M-o") 'handy-buffer/list-occurrences-at-point) ;; handy-buffer

   #+END_SRC

* Dealing with Windows

  Viewing windows simply as Emacs' containers of buffers. Here are
  some handy binds for switching between windows and manipulating
  windows, i.e., maximize, minimize and balance windows sizes.

  First, let's create a keymap to hold the windows related binds.

  #+BEGIN_SRC emacs-lisp

  (defvar seconf-window-map
    (make-sparse-keymap)
    "Window commands keymap.")

  #+END_SRC

  Next, we'll tell Emacs this keymap will be a =prefix key’s binding=
  and add it to the =ctl-x-map= under =w=:

  #+BEGIN_SRC emacs-lisp

  (define-prefix-command 'seconf-window-map)

  (define-key ctl-x-map (kbd "w") 'seconf-window-map)

  #+END_SRC

  Finally, let's add the actual key binds:

  #+BEGIN_SRC emacs-lisp

  ;; Manipulate windows
  (define-key seconf-window-map (kbd "1") 'maximize-window)
  (define-key seconf-window-map (kbd "q") 'minimize-window)
  (define-key seconf-window-map (kbd "w") 'balance-windows)

  ;; Navigate between windows
  (define-key seconf-window-map (kbd "i") 'windmove-up)
  (define-key seconf-window-map (kbd "k") 'windmove-down)
  (define-key seconf-window-map (kbd "j") 'windmove-left)
  (define-key seconf-window-map (kbd "l") 'windmove-right)

  #+END_SRC

* Minibuffer

  #+BEGIN_QUOTE
  The “minibuffer” is where Emacs commands read complicated arguments,
  such as file names, buffer names, Emacs command names, or Lisp
  expressions.  We call it the “minibuffer” because it’s a special-purpose
  buffer with a small amount of screen space.  You can use the usual Emacs
  editing commands in the minibuffer to edit the argument text.
  #+END_QUOTE

  Needles to say, this is an important section. Let's configure a
  bunch of things related to =completion= in the minibuffer:

  #+BEGIN_SRC emacs-lisp

  ;; if non-nil, 'read-answer' accepts single-character answers
  (customize-set-variable 'read-answer-short t)

  ;; non-nil means completion ignores case when reading a buffer name
  (customize-set-variable 'read-buffer-completion-ignore-case t)

  ;; non-nil means when reading a file name completion ignores case
  (customize-set-variable 'read-file-name-completion-ignore-case t)

  ;; number of completion candidates below which cycling is used
  (customize-set-variable 'completion-cycle-threshold nil)

  ;; treat the SPC or - inserted by `minibuffer-complete-word as delimiters
  (customize-set-variable 'completion-pcm-complete-word-inserts-delimiters t)

  ;; a string of characters treated as word delimiters for completion
  ;; (customize-set-variable 'completion-pcm-word-delimiters "-_./:| ")

  ;; non-nil means show help message in *Completions* buffer
  (customize-set-variable 'completion-show-help nil)

  ;; non-nil means automatically provide help for invalid completion input
  (customize-set-variable 'completion-auto-help 'lazy)

  ;; list of completion styles to use: see 'completion-styles-alist variable
  (customize-set-variable 'completion-styles
                          '(basic partial-completion emacs22 flex))
  ;; '(basic partial-completion substring flex))

  ;; list of category-specific user overrides for completion styles.
  (customize-set-variable 'completion-category-overrides nil)
  ;; '((file (styles initials basic))
  ;;   (buffer (styles initials basic))
  ;;   (info-menu (styles basic))))

  ;; define the appearance and sorting of completions
  (customize-set-variable 'completions-format 'horizontal)

  ;; how to resize mini-windows (the minibuffer and the echo area)
  ;; a value of t means resize them to fit the text displayed in them
  (customize-set-variable 'resize-mini-windows nil)

  ;; if non-nil, shorten "(default ...)" to "[...]" in minibuffer prompts
  (customize-set-variable 'minibuffer-eldef-shorten-default t)

  ;; non-nil means to delete duplicates in history
  (customize-set-variable 'history-delete-duplicates t)

  ;; non-nil means to allow minibuffer commands while in the minibuffer
  ;; (customize-set-variable 'enable-recursive-minibuffers nil)

  #+END_SRC

  And let's also add a key bind to call for completions when in
  =minibuffer=:

  #+BEGIN_SRC emacs-lisp

  (define-key minibuffer-local-map (kbd "<tab>") 'minibuffer-complete)

  #+END_SRC

* Icomplete

  #+BEGIN_QUOTE
  Icomplete global minor mode provides a convenient way to quickly select
  an element among the possible completions in a minibuffer.  When
  enabled, typing in the minibuffer continuously displays a list of
  possible completions that match the string you have typed.
  #+END_QUOTE

  From =Info= section =20.7.2 Fast minibuffer selection=. Here are a
  bunch of usage configurations for =Icomplete=.

  #+BEGIN_SRC emacs-lisp

  ;; pending-completions number over which to apply `icomplete-compute-delay
  (customize-set-variable 'icomplete-delay-completions-threshold 128)

  ;; maximum number of initial chars to apply `icomplete-compute-delay
  (customize-set-variable 'icomplete-max-delay-chars 0.3)

  ;; completions-computation stall, used only with large-number completions
  (customize-set-variable 'icomplete-compute-delay 0.1)

  ;; when non-nil, show completions when first prompting for input
  (customize-set-variable 'icomplete-show-matches-on-no-input t)

  ;; when non-nil, hide common prefix from completion candidates
  (customize-set-variable 'icomplete-hide-common-prefix nil)

  ;; maximum number of lines to use in the minibuffer
  (customize-set-variable 'icomplete-prospects-height 1)

  ;; string used by Icomplete to separate alternatives in the minibuffer
  (customize-set-variable 'icomplete-separator (propertize " · " 'face 'shadow))

  ;; specialized completion tables with which `icomplete should operate,
  ;; if this is t, `icomplete operates on all tables
  (customize-set-variable 'icomplete-with-completion-tables t)

  ;; if non-nil, also use icomplete when completing in non-mini buffers
  (customize-set-variable 'icomplete-in-buffer nil)

  #+END_SRC

  Now let's add some =very useful= binds in making =icomplete= in the
  =minibuffer= have a fast and realiable usage:

  #+BEGIN_SRC emacs-lisp

  (eval-after-load 'icomplete
    (lambda ()
      (when (boundp 'icomplete-minibuffer-map)

        (define-key icomplete-minibuffer-map (kbd "C-SPC") 'icomplete-force-complete-and-exit)
        (define-key icomplete-minibuffer-map (kbd "C-n") 'icomplete-forward-completions)
        (define-key icomplete-minibuffer-map (kbd "C-p") 'icomplete-backward-completions)
        (define-key icomplete-minibuffer-map (kbd "M-p") 'previous-line-or-history-element)
        (define-key icomplete-minibuffer-map (kbd "M-n") 'next-line-or-history-element)

        ;; TODO: third party functions
        ;; (define-key icomplete-minibuffer-map (kbd "M-i") 'handy/minibuffer-insert-completion-at-point)
        ;; (define-key icomplete-minibuffer-map (kbd "M-k") 'handy/minibuffer-kill-current-completion)
        ;; (define-key icomplete-minibuffer-map (kbd "M-h") 'handy/minibuffer-describe-current-completion)
        )))

  #+END_SRC

  Finally, let's enable =icomplete-mode= globally:

  #+BEGIN_SRC emacs-lisp

  (add-hook 'window-setup-hook
            (lambda ()
              (funcall 'icomplete-mode 1)))

  #+END_SRC

* In buffer completion

  Emacs makes the distinction between "minibuffer completion" (already
  covered and configured in this file) and "in buffer" completion
  (even though all completion is somewhat related to the minibuffer).

  The distinctions in this section will be regarding "native"
  completion functionalities (i.e., Emacs builtin) and third-party
  libraries.

** Built-in

   Out-of-the-box completion functionalities.

*** dabbrev

    =dabbrev= is the simplest possible package for completion, it
    simply looks for known words and has a couple of available
    configurable variables.

    #+BEGIN_QUOTE
    The purpose with this package is to let you write just a few
    characters of words you've written earlier to be able to expand
    them.

    To expand a word, just put the point right after the word and press
    M-/ (dabbrev-expand) or M-C-/ (dabbrev-completion).
    #+END_QUOTE

    We'll do some simple configurations:

    #+BEGIN_SRC emacs-lisp

    ;; non-nil means case sensitive search.
    (customize-set-variable 'dabbrev-upcase-means-case-search nil)

    ;; whether dabbrev treats expansions as the same if they differ
    ;; in case a value of nil means treat them as different.
    (customize-set-variable 'dabbrev-case-distinction nil)

    #+END_SRC

*** hippie-exp

    #+BEGIN_QUOTE
    `hippie-expand' is a single function for a lot of different kinds
    of completions and expansions.  Called repeatedly it tries all
    possible completions in succession.
    Which kinds of completions to try, and in which order, is
    determined by the contents of `hippie-expand-try-functions-list'.
    Much customization of `hippie-expand' can be made by changing the
    order of, removing, or inserting new functions in this list.
    Given a positive numeric argument, `hippie-expand' jumps directly
    ARG functions forward in this list.  Given some other argument
    (a negative argument or just Ctrl-U) it undoes the tried
    completion.
    #+END_QUOTE

    And the default value of =hippie-expand-try-functions-list= is
    very satisfying.

    So, we'll simply set a key bind for calling =hippie-expand=:

    #+BEGIN_SRC emacs-lisp

    (global-set-key (kbd "M-\\") 'hippie-expand)

    #+END_SRC

*** completion-at-point-function

    #+BEGIN_QUOTE
    completion-at-point-functions is a variable defined in
    ‘minibuffer.el’.
    ...
    Special hook to find the completion table for the entity at point.
    #+END_QUOTE

    This is the most "general-purpose" option here and it's (at least
    it should be) how third-party libraries insert themselves in
    Emacs' completion flow.

    This is not what happens with solutions like "company", which
    we'll avoid in this configuration.

** Third-party

   External libraries that handle completion.

*** corfu

    =corfu= is a third-party completion UI that relies on Emacs'
    native completion features and also the pluggable backends called
    =completion-at-point-functions=.

    #+BEGIN_QUOTE
    Corfu does not include its own completion backends. The Emacs
    built-in Capfs and the Capfs provided by third-party programming
    language packages are often sufficient.
    #+END_QUOTE

    /Note: This section is a work in progress./

    The following are some initial configurations for =corfu=:

    #+BEGIN_SRC emacs-lisp

    ;; These are all a matter of personal preference, one should tweak
    ;; these variables around to find the best combination for themselves
    (customize-set-variable 'corfu-auto t)        ;; Enable auto completion
    (customize-set-variable 'corfu-cycle t)                    ;; Enable cycling for `corfu-next/previous'
    (customize-set-variable 'corfu-separator ?\s)              ;; Orderless field separator
    (customize-set-variable 'corfu-quit-at-boundary t)         ;; Quit at completion boundary, i.e., if word is over
    (customize-set-variable 'corfu-quit-no-match t)            ;; Quit  if there is no match
    (customize-set-variable 'corfu-preview-current 'insert)    ;; Candidate is automatically inserted on further input
    (customize-set-variable 'corfu-preselect 'first)           ;; Always pre-select first candidate
    (customize-set-variable 'corfu-auto-prefix 2)              ;; Start completing after two characters
    (customize-set-variable 'corfu-scroll-margin 5)

    #+END_SRC

    Also, some keybinds for my personal flow:

    #+BEGIN_SRC emacs-lisp

    (eval-after-load 'corfu
      (lambda ()
        (when (boundp 'corfu-map)
          (define-key corfu-map (kbd "C-j") 'corfu-insert)
          ;; leave my ctrl-m alone. not sure about this.
          ;; (define-key corfu-map (kbd "RET") nil)
          )))

    #+END_SRC

    Finally, as recomended by the library's authors, enable it
    globally:

    #+BEGIN_SRC emacs-lisp

    :init
    (global-corfu-mode)

    #+END_SRC

*** cape

    Third-party =capfs= provider.

    Question: How to handle 'completion-at-point-functions being
    locally overwritten?

    Answer: Simply add the =capfs= that should always be present after
    changing major modes (maybe, let's see).

    #+BEGIN_SRC emacs-lisp

    (add-hook 'after-change-major-mode-hook
              (lambda ()
                (add-to-list 'completion-at-point-functions #'cape-file)
                (add-to-list 'completion-at-point-functions #'cape-dabbrev)))

    #+END_SRC

* Project Management

  Initially, we used =projectile= for this, however, it might no
  longer be needed. Emacs has a =project= library at its core now,
  that has basically all projectile features we need.

  After confirmation, =projectile= is now deprecated (in this
  configuration file). In its place, we'll have Emacs' internal
  =project.el=. It came with a few different binds and flows, but all
  the functionality is there.

  Some helpful binds:

  #+BEGIN_SRC emacs-lisp

  (define-key project-prefix-map (kbd "o") 'project-switch-project)
  (define-key project-prefix-map (kbd "p") 'ag-project)

  #+END_SRC

  =Note:= When using =project.el=, if the newly added project is an
  empty directory, an error will occur.

* Version Control (magit)

  /Note: Please refer to [[https://magit.vc/manual/magit/Installing-from-the-Git-Repository.html][this manual]] for Magit's installation and/
  /proper =loaddefs= generation./

  Magit is a true git porcelain. So, we're simply going to bind a key
  to invoke Magit from a project:

  #+BEGIN_SRC emacs-lisp

  (define-key ctl-x-map (kbd "j") 'magit-status)

  #+END_SRC

  Magit has a couple of external denpencies:

  - =compat=, =dash=, =transient= and =with-editor=.

  And adding the following key-binds to =text-mode-map= is useful when
  editing commit messages.

  #+BEGIN_SRC emacs-lisp

  (define-key text-mode-map (kbd "C-c C-k") 'with-editor-cancel)
  (define-key text-mode-map (kbd "C-c C-c") 'with-editor-finish)

  #+END_SRC

* Org Mode

  #+BEGIN_QUOTE
  Org Mode is an authoring tool and a TODO lists manager for GNU Emacs.
  It relies on a lightweight plain-text markup language used in files with
  the ‘.org’ extension.
  #+END_QUOTE

  Org is amazing and makes so many things (like this configuration
  file) possible.

  Here are some simple configurations:

  #+BEGIN_SRC emacs-lisp

  ;; when non-nil, fontify code in code blocks
  (customize-set-variable 'org-src-fontify-natively t)

  ;; if non-nil, the effect of TAB in a code block is as if it were
  ;; issued in the language major mode buffer
  (customize-set-variable 'org-src-tab-acts-natively t)

  ;; indentation for the content of a source code block.
  (customize-set-variable 'org-edit-src-content-indentation 0)

  ;; confirm before evaluation
  (customize-set-variable 'org-confirm-babel-evaluate t)

  ;; how the source code edit buffer should be displayed
  (customize-set-variable 'org-src-window-setup 'current-window)

  ;; non-nil means C-a and C-e behave specially in headlines and items
  (customize-set-variable 'org-special-ctrl-a/e t)

  ;; non-nil means adapt indentation to outline node level.
  ;; important: without this org messes up the file indentation.
  (customize-set-variable 'org-adapt-indentation t)

  #+END_SRC

  And, as seen in this file, Org allows for code block
  execution/evaluation and to inform Org of the languages we wish to
  use, we have to add entries to the =org-babel-load-languages=
  variable:

  #+BEGIN_SRC emacs-lisp

  (add-hook 'org-mode-hook
            (lambda ()
              ;; do not truncate lines
              (setq truncate-lines nil)

              ;; languages which can be evaluated in Org buffers.
              (org-babel-do-load-languages
               'org-babel-load-languages
               '((emacs-lisp . t)
                 (shell . t)
                 (python . t)))

              ;; also add dict based capf to capfs
              (add-to-list 'completion-at-point-functions #'cape-dict)))

  #+END_SRC

  Finally, as Org is also (and mainly) text, we'll do a small but very
  important tweak to =text-mode= to ensure text is well suited for
  humans to read. Particularly speaking of lines that are too long,
  we'll use =auto-fill-mode= to keep this nice sized paragraphs you're
  probably seen while reading this file:

  #+BEGIN_QUOTE
  When Auto Fill mode is enabled, inserting a space at a column
  beyond ‘current-fill-column’ automatically breaks the line at a
  previous space.
  #+END_QUOTE

  #+BEGIN_SRC emacs-lisp

  (add-hook 'text-mode-hook
            (lambda ()
              (turn-on-auto-fill)))

  #+END_SRC

* Terminals

  For now, we'll be using =term.el= with two clever binds, but first,
  let's write a function that runs a terminal and asks for its name:

  #+BEGIN_SRC emacs-lisp

  (defun seconf/run-term ()
    (interactive)
    (term (getenv "SHELL"))
    (rename-buffer
     (read-string "Rame term buffer: " nil nil "term") t))

  #+END_SRC

  Note that the =SHELL= variable must be set. Now let's bind this
  function to a comfortable key combination (imo):

  #+BEGIN_SRC emacs-lisp

  (define-key ctl-x-map (kbd "RET") 'seconf/run-term)

  #+END_SRC

  Also, in order for us to properly navigate through the terminal
  buffer:

  #+BEGIN_SRC emacs-lisp

  (add-hook 'term-mode-hook
            (lambda ()
              (when (and (boundp 'term-raw-map)
                         (boundp 'term-mode-map))
                ;; term-raw-map
                (define-key term-raw-map (kbd "C-z") 'term-line-mode)

                ;; term-mode-map
                (define-key term-mode-map (kbd "C-z") 'term-char-mode))))

  #+END_SRC

* Programming

  This section holds "generic" customizations/configurations used when
  programming, i.e., when =prog-mode= is active.

  Language specific configurations will be contained in other files to
  be included in this section of this "main file" and tied together in
  the build process.

  /Note: some of the settings here could also be placed in the/
  /"Dealing with buffers" section./

  Starting with =subword=: this package provides a minor mode, which
  merges the old remap-based subword.el (derived from cc-mode code)
  and cap-words.el, which takes advantage of core Emacs
  word-motion-customization functionality.

  It's very good for navigating over =CamelCase=.

  #+BEGIN_SRC emacs-lisp

  (add-hook 'window-setup-hook
            (lambda ()
              (funcall 'global-subword-mode 1)))

  #+END_SRC

  It is also generally good being able to hide blocks of
  code/comments, so we'll use the  =hideshow= library for this:

  #+BEGIN_SRC emacs-lisp

  ;; activate hs-minor-mode when programming
  (add-hook 'prog-mode-hook 'hs-minor-mode)

  ;; add a noice bind to it
  (define-key ctl-x-map (kbd "[") 'hs-toggle-hiding)

  #+END_SRC

* General Customizations

  Disabling all "bars" in order to have a "clean screen":

  #+BEGIN_SRC emacs-lisp

  (custom-set-variables
   '(menu-bar-mode nil)
   '(scroll-bar-mode nil)
   '(tool-bar-mode nil))

  #+END_SRC

* What's missing
** DONE Finish Custom Lex library

   For now, only =lex-buffer.el= is required;
   This is now called =handy-buffer.el= and it's available at:
   https://github.com/yagossc/el-handy/

** TODO Check other Lex dependencies

   - There's dependency in =lex-minibuffer= for a few useful functions
   regarding minibuffer completion.

** DONE Lazy loading

   Adapt to new el-lazy.

   I actually preferred creating a simple function to manually deal
   with this.

** TODO Git submodules

   Organize third party libraries as git submodules forked in my own
   github.

*** ag.el

    - git@github.com:Wilfred/ag.el.git

**** Dependencies

     - git@github.com:magnars/s.el.git
     - git@github.com:magnars/dash.el.git

*** browse-kill-ring

    - git@github.com:browse-kill-ring/browse-kill-ring.git

*** cape

    - git@github.com:minad/cape.git

*** corfu

    - git@github.com:minad/corfu.git

*** magit

    - git@github.com:magit/magit.git

**** Dependencies

     - git@github.com:magnars/dash.el.git
     - git@github.com:magit/transient.git
     - git@github.com:magit/with-editor.git
     - git@github.com:emacs-compat/compat.git

** TODO Install script

   This should contain the following:

*** DONE Create if doesn't exist: "~/.emacs.d" symbolic link

    #+BEGIN_SRC sh

    _src_dir=$(pwd)

    echo $_src_dir

    if [ -e ~/.emacs.d ]
    then
        echo "[INFO] ~/.emacs.d symbolic link already exists"
    else
        ln -s $_src_dir ~/.emacs.d
    fi

    #+END_SRC

*** DONE Create if doesn't exist: ~/.emacs.d/lisp

    #+BEGIN_SRC sh

    if [ -e ~/.emacs.d/lisp ]
    then
        echo "[INFO] ~/.emacs.d/lisp dir already exists"
    else
        mkdir ~/.emacs.d/lisp
    fi

    #+END_SRC

*** TODO Create if doesn't exist: ~/.emacs.d/lisp/subdirs.el

    It might make more sense for this to be part of the =init.el= and
    not an =install.sh= script.

*** TODO Magit particular installation steps

    This includes manually adding some directories to =LOADPATH= and
    running =make=. See the instructions [[https://magit.vc/manual/magit/Installing-from-the-Git-Repository.html][here]].

*** TODO Ag and its dependencies

    - Ag's source: https://github.com/ggreer/the_silver_searcher
    - ag.el source: https://github.com/Wilfred/ag.el
    - s.el (ag.el dependency): https://github.com/magnars/s.el

*** TODO Ispell dictionaries

    - Brazillian portuguese dictionary has to be manually installed,
    i.e., cloned from github.
    - Also, remember that aspell is an Unix utility, meaning it has to
      be installed in the system for any of the "ispell-*" commands to
      work.

** DONE Create needed sections

   As of now, it seems to make sense to have the 3 sections:
   - Frames;
   - Windows;
   - Buffers;

   And add to them all the global "generic" configurations (hooks,
   macros, variable customizations, etc.

   Also maybe a "Display" or "Screen" section for things like the
   menubar, highlight line, etc.

** TODO Theme

   - Fiddle with darcula theme until good enough;
   - Remove unused customizations;

** DONE Minibuffer

   This takes its own section

** DONE Custom file

   The =custom.el= is a good place for calls like

   #+BEGIN_SRC emacs-lisp :tangle no

   (safe-funcall 'menu-bar-mode 0)

   #+END_SRC

   This might not really be needed.

** TODO Completion

   This could get its own section

** TODO Terminals

   This could get its own section.

*** DONE Basic Usage

    - Open a terminal an rename it;
    - Navigate it with "terminal functionality" disabled/enabled.

*** TODO Dedicated terminal

    Emacs has dedicated windows.

    Check Matering Emacs' [[https://www.masteringemacs.org/article/demystifying-emacs-window-manager][post]].

** DONE Org mode

   This could get its own section

** TODO Documentation

   Here there could be configurations for =man=, =woman= and
   =dash-docs=.

*** TODO Dash Docs for
** TODO Iedit
** TODO Yasnippet
** TODO Undo-tree
** TODO Etags
** TODO Xref
** DONE Project Management

   Here goes magit and projectile and that's it.

*** DONE Magit
*** DONE Projectile
** TODO Programming

   Here goes the editing code specifics.

*** TODO General

    Prog-mode stuff maybe?

*** TODO Language Specific

    Idea: include other files.

    This can, indeed, be done. It's "hackish", but it works fine. It
    goes like this:

    - In the main .org file, =#+INCLUDE= all other needed .org files;
    - In the main .org file, give it a =#+EXPORT_FILE_NAME=;
    - In the =build.el= script, add the call
      =(org-org-export-to-org)=, which will export the main .org file
      to $export_file_name (including the contents of all #INCLUDE
      files);
    - Tangle normally;
    - Done.

** TODO Cleanup

   For removing key-binds from minor modes, etc.
