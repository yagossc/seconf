#+TITLE: Emacs Configuration File
#+AUTHOR: yago
#+DESCRIPTION: An Org based Emacs configuration.
#+KEYWORDS: emacs, org, config, init.el
#+LANGUAGE: en
#+BABEL: :cache yes
#+PROPERTY: header-args :tangle yes

* Initialization

  #+BEGIN_QUOTE
  In the beginning...
  #+END_QUOTE

** Loading/Library Search

   From Emacs' Info file, section =16.3 Library Search=:

   #+BEGIN_QUOTE
   When Emacs loads a Lisp library, it searches for the library in a list
   of directories specified by the variable ‘load-path’.

   ...
   When Emacs starts up, it sets up the value of ‘load-path’ in several
   steps.  First, it looks for the directory containing its own Lisp files,
   using default locations set when Emacs was compiled.

   ...
   If the environment variable ‘EMACSLOADPATH’ is set, it modifies the
   above initialization procedure.  Emacs initializes ‘load-path’ based on
   the value of the environment variable.

   The syntax of ‘EMACSLOADPATH’ is the same as used for ‘PATH’;
   directories are separated by ‘:’ (or ‘;’, on some operating
   systems).

   ...
   #+END_QUOTE

   This is important because we don't use a package manager for the
   chosen external libraries. We handle our dependencies by adding our
   =~/.emacs.d/lisp= directory (containing the external libraries) to
   Emacs' =load-path= by using the =EMACSLOADPATH= environment
   variable. Therefore, the following snippet is present in our
   =.xinitrc= file:

   #+BEGIN_SRC sh

   export EMACSLOADPATH=~/.emacs.d/lisp:

   #+END_SRC

   Also, an important note on the syntax of this variable declaration:

   #+BEGIN_QUOTE
   An empty element in the value of the environment variable, whether
   trailing (as in the above example, note the trailing ‘:’), leading, or
   embedded, is replaced by the default value of ‘load-path’ as determined
   by the standard initialization procedure.  If there are no such empty
   elements, then ‘EMACSLOADPATH’ specifies the entire ‘load-path’.
   #+END_QUOTE

   So don't forget the ":" in the end of the environment variable
   declaration.

   Finally, there's the need of a =subdirs.el= file to tell Emacs to
   recursively add all directories inside of our custom =load-path=
   entry to the =load-path= itself.

   #+BEGIN_QUOTE
   For each directory in ‘load-path’, Emacs then checks to see if it
   contains a file ‘subdirs.el’, and if so, loads it.  The ‘subdirs.el’
   file is created when Emacs is built/installed, and contains code that
   causes Emacs to add any subdirectories of those directories to
   ‘load-path’.
   #+END_QUOTE

   And such code contained in the =subdirs.el= file is:

   #+BEGIN_SRC emacs-lisp :tangle no

   (if (fboundp 'normal-top-level-add-subdirs-to-load-path)
       (normal-top-level-add-subdirs-to-load-path))

   #+END_SRC

   The use of a "custom load-path directory" is tied to the use of the
   =autload= funcionality described in the next section.

** Autoload

   #+BEGIN_QUOTE
   The “autoload” facility lets you register the existence of a function or
   macro, but put off loading the file that defines it.  The first call to
   the function automatically loads the proper library,
   ...
   #+END_QUOTE

   A common problem with other Emacs configurations is a =very slow
   startup=. By using the =autoload= facility, we can avoid loading
   unecessary information onto memory before it's actually needed.

   For this to work, we need a =loaddefs= file generated by some
   function like =loaddefs-generate= (the most up to date option
   today, February second, 2024).

   There's the =loaddefs= file generated by Emacs itself for its own
   Lisp files, so let's load those symbol's:

   #+BEGIN_SRC emacs-lisp

   (require 'loaddefs)

   #+END_SRC

   We now need our custom libraries' symbols. So we'll generate a
   =lisp-loaddefs.el= file inside our =load-path= entry, i.e., inside
   of =~/.emacs.d/lisp=.

   To generate this file we'll need a function that:
   1. Goes through every sub-directory in our target directory;
   2. Calls the =loaddefs-generate= function for that dir to collect
      all definitions marked with the magic =;;;###autoload= comment;
   3. Add those symbols to our =lisp-loaddefs.el=.

   As an extra credit, our function will allow =interactive= calls, in
   which case the =lisp=loaddefs.el= file will be entirely
   "regenerated".

   #+BEGIN_SRC emacs-lisp

   (require 'cl-seq)

   (defun seconf/generate-loaddefs (&optional generate-full)
     "Generate loaddefs file for all directories inside of `user-emacs-directory/lisp'.
   If called interactively, regenerate all the loaddefs files anew, instead of just
   updating it (if needed)."
     (interactive "p")
     (let ((dir (expand-file-name "lisp/" user-emacs-directory))
           (outputfile "lisp-loaddefs.el"))
       (loaddefs-generate
        (cl-remove-if-not #'file-directory-p (directory-files-recursively dir "^[^.]" t))
        (expand-file-name outputfile dir) nil nil nil generate-full)
       (when generate-full
         (message "Fully generated new lisp-loaddefs.el file"))))

   #+END_SRC

   We can now add this function call to an early hook to ensure we
   create or update our =lisp-loaddefs.el= file as we start a session.

   #+BEGIN_SRC emacs-lisp

   (add-hook 'window-setup-hook
             (lambda ()
               (seconf/generate-loaddefs)))

   #+END_SRC

   Finally, we can load our symbols onto memory, by calling =require=
   (and telling it not break in case the file is not found).

   #+BEGIN_SRC emacs-lisp

   (require 'lisp-loaddefs nil t)
   ;; (setq load-prefer-newer noninteractive)

   #+END_SRC

* Global Key Binds

  Here are some very useful general purpose keybinds for both
  navigating and editing buffers in Emacs.

  The depencies here are:
  1. handy-buffer.el (3rd party);
  2. browse-kill-ring.el (3rd party);
  3. simple.el;
  4. window.el;

  #+BEGIN_SRC emacs-lisp

  ;; line movement
  (global-set-key (kbd "C-a") 'handy-buffer/back-to-indent-or-line) ;; handy-buffer.el
  (global-set-key (kbd "C-e") 'move-end-of-line)

  ;; word movement
  (global-set-key (kbd "C-<left>") 'backward-word)
  (global-set-key (kbd "C-<right>") 'forward-whitespace)

  ;; scroll movement
  (global-set-key (kbd "C-M-v") 'scroll-other-window)
  (global-set-key (kbd "C-M-y") 'scroll-other-window-down)

  ;; edit
  (global-set-key (kbd "M-y") 'browse-kill-ring) ;; browse-kill-ring.el
  (global-set-key (kbd "M-i") 'handy-buffer/indent-region-or-buffer) ;; handy-buffer.el
  (global-set-key (kbd "M-j") 'handy-buffer/duplicate-line-or-region) ;; handy-buffer.el
  (global-set-key (kbd "M-n") 'handy-buffer/transpose-lines-up) ;; handy-buffer.el
  (global-set-key (kbd "M-p") 'handy-buffer/transpose-lines-down) ;; handy-buffer.el
  (global-set-key (kbd "M-l") 'downcase-word)
  (global-set-key (kbd "C-w") 'handy-buffer/kill-region-or-backward-word) ;; handy-buffer.el

  ;; search
  (global-set-key (kbd "M-s M-o") 'handy-buffer/list-occurrences-at-point) ;; handy-buffer

  ;; kill
  (define-key ctl-x-map (kbd "k") 'kill-buffer)

  ;; keyboard quit. might remove this. not really used.
  (global-set-key (kbd "M-ESC") 'keyboard-escape-quit)

  ;; in buffer completion
  ;; (global-set-key (kbd "C-M-i") 'complete-or-indent)

  #+END_SRC

* Dealing with Directories (dired)

  =dired= is the main tool for dealing with directories inside Emacs.
  Here are some really minor tweaks for an improved usage.

  Avoid creating a bunch of buffers from the directories accessed from
  =dired=:

  #+BEGIN_SRC emacs-lisp

  ;; enable dired-find-alternate-file
  (add-hook 'window-setup-hook
            (lambda ()
              (put 'dired-find-alternate-file 'disabled nil)))

  #+END_SRC

  And add some key-binds to improve usability:

  #+BEGIN_SRC emacs-lisp

  ;; dired-mode-map
  (eval-after-load 'dired
    (lambda ()
      (when (boundp 'dired-mode-map)
        (define-key dired-mode-map (kbd "RET") 'dired-find-alternate-file)
        (define-key dired-mode-map (kbd "C-j") 'dired-find-alternate-file))))

  #+END_SRC


* Dealing with Buffers
* Project Management

  We'll use two libraries for project management and this choice
  assumes we use =git= for the majority our projects.

** Projectile

   Might not be needed. Emacs has a =project= library at its core now,
   that has basically all projectile features we need.

* Version Control (magit)

  Magit is a true git porcelain. So, we're simply going to bind a key
  to invoke Magit from a project:

  #+BEGIN_SRC emacs-lisp

  (define-key ctl-x-map (kbd "j") 'magit-status)

  #+END_SRC

  Magit has a couple of external denpencies:

  - =compat=, =dash=, =transient= and =with-editor=.

  And adding the following key-binds to =text-mode-map= is useful when
  editing commit messages.

  #+BEGIN_SRC emacs-lisp

  (define-key text-mode-map (kbd "C-c C-k") 'with-editor-cancel)
  (define-key text-mode-map (kbd "C-c C-c") 'with-editor-finish)

  #+END_SRC

* Customizations

  Disabling all "bars" in order to have a "clean screen":

  #+BEGIN_SRC emacs-lisp

  (custom-set-variables
   '(menu-bar-mode nil)
   '(scroll-bar-mode nil)
   '(tool-bar-mode nil))

  #+END_SRC

* What's missing
** DONE Finish Custom Lex library

   For now, only =lex-buffer.el= is required;
   This is now called =handy-buffer.el= and it's available at:
   https://github.com/yagossc/el-handy/

** TODO Check other Lex dependencies
** DONE Lazy loading

   Adapt to new el-lazy.

   I actually preferred creating a simple function to manually deal
   with this.

** TODO Git submodules

   Organize third party libraries as git submodules forked in my own
   github.

** TODO Install script

   This should contain the following:

*** TODO Create if doesn't exist: ~/.emacs.d/ symbolic link
*** TODO Create if doesn't exist: ~/.emacs.d/lisp
*** TODO Create if doesn't exist: ~/.emacs.d/lisp/subdirs.le

** TODO Create needed sections

   As of now, it seems to make sense to have the 3 sections:
   - Frames;
   - Windows;
   - Buffers;

   And add to them all the global "generic" configurations (hooks,
   macros, variable customizations, etc.

   Also maybe a "Display" or "Screen" section for things like the
   menubar, highlight line, etc.

** TODO Minibuffer

   This takes its own section

** TODO Custom file

   The =custom.el= is a good place for calls like

   #+BEGIN_SRC emacs-lisp :tangle no

   (safe-funcall 'menu-bar-mode 0)

   #+END_SRC

** TODO Completion

   This could get its own section

** TODO Terminals

   This could get its own section

** TODO Org mode

   This could get its own section

** TODO Documentation

   Here there could be configurations for =man=, =woman= and
   =dash-docs=.

*** TODO Dash Docs for

** TODO Project Management

   Here goes magit and projectile and that's it.

*** DONE Magit
*** TODO Projectile

** TODO Programming

   Here goes the editing code specifics.

*** TODO General
*** TODO Language Specific

** TODO Cleanup

   For removing key-binds from minor modes, etc.
