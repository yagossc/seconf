#+TITLE: Emacs Configuration File
#+AUTHOR: yago
#+DESCRIPTION: An Org based Emacs configuration.
#+KEYWORDS: emacs, org, config, init.el
#+LANGUAGE: en
#+BABEL: :cache yes
#+PROPERTY: header-args :tangle yes

* Initialization

  #+BEGIN_QUOTE
  In the beginning...
  #+END_QUOTE

** Loading/Library Search

   From Emacs' Info file, section =16.3 Library Search=:

   #+BEGIN_QUOTE
   When Emacs loads a Lisp library, it searches for the library in a list
   of directories specified by the variable ‘load-path’.

   ...
   When Emacs starts up, it sets up the value of ‘load-path’ in several
   steps.  First, it looks for the directory containing its own Lisp files,
   using default locations set when Emacs was compiled.

   ...
   If the environment variable ‘EMACSLOADPATH’ is set, it modifies the
   above initialization procedure.  Emacs initializes ‘load-path’ based on
   the value of the environment variable.

   The syntax of ‘EMACSLOADPATH’ is the same as used for ‘PATH’;
   directories are separated by ‘:’ (or ‘;’, on some operating
   systems).

   ...
   #+END_QUOTE

   This is important because we don't use a package manager for the
   chosen external libraries. We handle our dependencies by adding our
   =~/.emacs.d/lisp= directory (containing the external libraries) to
   Emacs' =load-path= by using the =EMACSLOADPATH= environment
   variable. Therefore, the following snippet is present in our
   =.xinitrc= file:

   #+BEGIN_SRC sh

   export EMACSLOADPATH=~/.emacs.d/lisp:

   #+END_SRC

   Also, an important note on the syntax of this variable declaration:

   #+BEGIN_QUOTE
   An empty element in the value of the environment variable, whether
   trailing (as in the above example, note the trailing ‘:’), leading, or
   embedded, is replaced by the default value of ‘load-path’ as determined
   by the standard initialization procedure.  If there are no such empty
   elements, then ‘EMACSLOADPATH’ specifies the entire ‘load-path’.
   #+END_QUOTE

   So don't forget the ":" in the end of the environment variable
   declaration.

   Finally, there's the need of a =subdirs.el= file to tell Emacs to
   recursively add all directories inside of our custom =load-path=
   entry to the =load-path= itself.

   #+BEGIN_QUOTE
   For each directory in ‘load-path’, Emacs then checks to see if it
   contains a file ‘subdirs.el’, and if so, loads it.  The ‘subdirs.el’
   file is created when Emacs is built/installed, and contains code that
   causes Emacs to add any subdirectories of those directories to
   ‘load-path’.
   #+END_QUOTE

   And such code contained in the =subdirs.el= file is:

   #+BEGIN_SRC emacs-lisp :tangle no

   (if (fboundp 'normal-top-level-add-subdirs-to-load-path)
       (normal-top-level-add-subdirs-to-load-path))

   #+END_SRC

   The use of a "custom load-path directory" is tied to the use of the
   =autload= funcionality described in the next section.

** Autoload

   #+BEGIN_QUOTE
   The “autoload” facility lets you register the existence of a function or
   macro, but put off loading the file that defines it.  The first call to
   the function automatically loads the proper library,
   ...
   #+END_QUOTE

   A common problem with other Emacs configurations is a =very slow
   startup=. By using the =autoload= facility, we can avoid loading
   unecessary information onto memory before it's actually needed.

   For this to work, we need a =loaddefs= file generated by some
   function like =loaddefs-generate= (the most up to date option
   today, February second, 2024).

   There's the =loaddefs= file generated by Emacs itself for its own
   Lisp files, so let's load those symbol's:

   #+BEGIN_SRC emacs-lisp

   (require 'loaddefs)

   #+END_SRC

   We now need our custom libraries' symbols, so we'll generate a
   =lisp-loaddefs.el= file inside our =load-path= entry, i.e., inside
   of =~/.emacs.d/lisp=.

   To generate this file we'll need a function that:
   1. Goes through every sub-directory in our target directory;
   2. Calls the =loaddefs-generate= function for that dir to collect
      all definitions marked with the magic =;;;###autoload= comment;
   3. Add those symbols to our =lisp-loaddefs.el=.

   As an extra credit, our function will allow =interactive= calls, in
   which case the =lisp=loaddefs.el= file will be entirely
   "regenerated".

   #+BEGIN_SRC emacs-lisp

   (require 'cl-seq)

   (defun seconf/generate-loaddefs (&optional generate-full)
     "Generate loaddefs file for all directories inside of `user-emacs-directory/lisp'.
   If called interactively, regenerate all the loaddefs files anew, instead of just
   updating them with the new/changed autoloads."
     (interactive "p")
     (let ((dir (expand-file-name "lisp/" user-emacs-directory))
           (outputfile "lisp-loaddefs.el"))
       (loaddefs-generate
        (cl-remove-if-not #'file-directory-p (directory-files dir t "^[^.]"))
        (expand-file-name outputfile dir) nil nil nil generate-full)
       (when generate-full
         (message "Fully generated new lisp-loaddefs.el file"))))

   #+END_SRC

   We can now add this function call to an early hook to ensure we
   create or update our =lisp-loaddefs.el= file as we start a session.

   #+BEGIN_SRC emacs-lisp

   (add-hook 'window-setup-hook
             (lambda ()
               (seconf/generate-loaddefs)))

   #+END_SRC

   Finally, we can load our symbols onto memory, by calling =require=
   (and telling it not break in case the file is not found).

   #+BEGIN_SRC emacs-lisp

   (require 'lisp-loaddefs nil t)
   ;; (setq load-prefer-newer noninteractive)

   #+END_SRC

* Global Key Binds

  Here are some very useful general purpose keybinds for both
  navigating and editing buffers in Emacs.

  The depencies here are:
  1. handy-buffer.el (3rd party);
  2. browse-kill-ring.el (3rd party);
  3. simple.el;
  4. window.el;

     #+BEGIN_SRC emacs-lisp

     ;; line movement
     (global-set-key (kbd "C-a") 'handy-buffer/back-to-indent-or-line) ;; handy-buffer.el
     (global-set-key (kbd "C-e") 'move-end-of-line)

     ;; word movement
     (global-set-key (kbd "C-<left>") 'backward-word)
     (global-set-key (kbd "C-<right>") 'forward-whitespace)

     ;; scroll movement
     (global-set-key (kbd "C-M-v") 'scroll-other-window)
     (global-set-key (kbd "C-M-y") 'scroll-other-window-down)

     ;; edit
     (global-set-key (kbd "M-y") 'browse-kill-ring) ;; browse-kill-ring.el
     (global-set-key (kbd "M-i") 'handy-buffer/indent-region-or-buffer) ;; handy-buffer.el
     (global-set-key (kbd "M-j") 'handy-buffer/duplicate-line-or-region) ;; handy-buffer.el
     (global-set-key (kbd "M-n") 'handy-buffer/transpose-lines-up) ;; handy-buffer.el
     (global-set-key (kbd "M-p") 'handy-buffer/transpose-lines-down) ;; handy-buffer.el
     (global-set-key (kbd "M-l") 'downcase-word)
     (global-set-key (kbd "C-w") 'handy-buffer/kill-region-or-backward-word) ;; handy-buffer.el

     ;; search
     (global-set-key (kbd "M-s M-o") 'handy-buffer/list-occurrences-at-point) ;; handy-buffer

     ;; kill
     (define-key ctl-x-map (kbd "k") 'kill-buffer)

     ;; keyboard quit. might remove this. not really used.
     (global-set-key (kbd "M-ESC") 'keyboard-escape-quit)

     ;; in buffer completion
     ;; (global-set-key (kbd "C-M-i") 'complete-or-indent)

     #+END_SRC

* What's missing
** DONE Finish Custom Lex library

   For now, only =lex-buffer.el= is required;
   This is now called =handy-buffer.el= and it's available at:
   https://github.com/yagossc/el-handy/

** TODO Check other Lex dependencies
** DONE Lazy loading

   Adapt to new el-lazy.

   I actually preferred creating a simple function to manually deal
   with this.

** TODO Git submodules

   Organize third party libraries as git submodules forked in my own
   github.
