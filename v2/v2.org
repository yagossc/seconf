#+TITLE: Emacs Configuration File
#+AUTHOR: yago
#+DESCRIPTION: An Org based Emacs configuration.
#+KEYWORDS: emacs, org, config, init.el
#+LANGUAGE: en
#+BABEL: :cache yes
#+PROPERTY: header-args :tangle yes

* Initialization

  #+BEGIN_QUOTE
  In the beginning...
  #+END_QUOTE

** Loading/Library Search

   From Emacs' Info file, section =16.3 Library Search=:

   #+BEGIN_QUOTE
   When Emacs loads a Lisp library, it searches for the library in a list
   of directories specified by the variable ‘load-path’.

   ...
   When Emacs starts up, it sets up the value of ‘load-path’ in several
   steps.  First, it looks for the directory containing its own Lisp files,
   using default locations set when Emacs was compiled.

   ...
   If the environment variable ‘EMACSLOADPATH’ is set, it modifies the
   above initialization procedure.  Emacs initializes ‘load-path’ based on
   the value of the environment variable.

   The syntax of ‘EMACSLOADPATH’ is the same as used for ‘PATH’;
   directories are separated by ‘:’ (or ‘;’, on some operating
   systems).

   ...
   #+END_QUOTE

   This is important because we don't use a package manager for the
   chosen external libraries. We handle our dependencies by adding our
   =~/.emacs.d/lisp= directory (containing the external libraries) to
   Emacs' =load-path= using the =EMACSLOADPATH= environment variable.
   Therefore, the following snippet is present in our =.xinitrc= file:

   #+BEGIN_SRC sh

   export EMACSLOADPATH=~/.emacs.d/lisp:

   #+END_SRC

   Also, an important note on the syntax of this variable declaration:

   #+BEGIN_QUOTE
   An empty element in the value of the environment variable, whether
   trailing (as in the above example, note the trailing ‘:’), leading, or
   embedded, is replaced by the default value of ‘load-path’ as determined
   by the standard initialization procedure.  If there are no such empty
   elements, then ‘EMACSLOADPATH’ specifies the entire ‘load-path’.
   #+END_QUOTE

   So don't forget the ":" in the end of the environment variable
   declaration.

   Finally, there's the need of a =subdirs.el= file to tell Emacs to
   recursively add all directories inside of our custom =load-path=
   entry to the =load-path= itself.

   #+BEGIN_QUOTE
   For each directory in ‘load-path’, Emacs then checks to see if it
   contains a file ‘subdirs.el’, and if so, loads it.  The ‘subdirs.el’
   file is created when Emacs is built/installed, and contains code that
   causes Emacs to add any subdirectories of those directories to
   ‘load-path’.
   #+END_QUOTE

   And such code contained in the =subdirs.el= file is:

   #+BEGIN_SRC emacs-lisp :tangle no

   (if (fboundp 'normal-top-level-add-subdirs-to-load-path)
       (normal-top-level-add-subdirs-to-load-path))

   #+END_SRC

   /NOTE: One can also read more about Emacs' startup at the Info/
   /section "Startup Summary"./
   /Refer to: =C-h= =i= =g= (elisp)Startup Summary RET/

   The use of a "custom load-path directory" is tied to the use of the
   =autload= funcionality described in the next section.

** Autoload

   #+BEGIN_QUOTE
   The “autoload” facility lets you register the existence of a function or
   macro, but put off loading the file that defines it.  The first call to
   the function automatically loads the proper library,
   ...
   #+END_QUOTE

   A common problem with other Emacs configurations is a =very slow
   startup=. By using the =autoload= facility, we can avoid loading
   unecessary information onto memory before it's actually needed.

   For this to work, we need a =loaddefs= file generated by some
   function like =loaddefs-generate= (the most up to date option
   today, February second, 2024).

   There's the =loaddefs= file generated by Emacs itself for its own
   Lisp files, so let's load those symbol's:

   #+BEGIN_SRC emacs-lisp

   (require 'loaddefs)

   #+END_SRC

   We now need our custom libraries' symbols. So we'll generate a
   =lisp-loaddefs.el= file inside our =load-path= entry, i.e., inside
   of =~/.emacs.d/lisp=.

   To generate this file we'll need a function that:
   1. Goes through every sub-directory in our target directory;
   2. Calls the =loaddefs-generate= function for that dir to collect
      all definitions marked with the magic =;;;###autoload= comment;
   3. Add those symbols to our =lisp-loaddefs.el=.


   As an extra credit, our function will allow =interactive= calls, in
   which case the =lisp=loaddefs.el= file will be entirely
   "regenerated".

   #+BEGIN_SRC emacs-lisp

   (require 'cl-seq)

   (defun seconf/generate-loaddefs (&optional generate-full)
     "Generate loaddefs file for all directories inside of `user-emacs-directory/lisp'.
   If called interactively, regenerate all loaddefs."
     (interactive "p")
     (let ((dir (expand-file-name "lisp/" user-emacs-directory))
           (outputfile "lisp-loaddefs.el"))
       (loaddefs-generate
        (cl-remove-if-not #'file-directory-p (directory-files-recursively dir "^[^.]" t))
        (expand-file-name outputfile dir) nil nil nil generate-full)
       (when generate-full
         (message "Fully generated new lisp-loaddefs.el file"))))

   #+END_SRC

   We can now add this function call to an early hook to ensure we
   create or update our =lisp-loaddefs.el= file as we start a session.

   #+BEGIN_SRC emacs-lisp

   (add-hook 'window-setup-hook
             (lambda ()
               (seconf/generate-loaddefs)))

   #+END_SRC

   Finally, we can load our symbols onto memory, by calling =require=
   (and telling it not break in case the file is not found).

   #+BEGIN_SRC emacs-lisp

   (require 'lisp-loaddefs nil t)
   ;; (setq load-prefer-newer noninteractive)

   #+END_SRC

** History and Cache

   For many functionalities that go through the minibuffer, having a
   list of =previously used candidates= depends on having a set
   =history variable= (that can also be viewed as a cached list of
   candidates). Among these variables we have things such as:
   =extended-command-history=, =file-name-history=,
   =minibuffer-history=, =buffer-name-history=,
   =shell-command-history= and many others.

   Needles to say, this is a "must have" feature to be enabled.

   Therefore, we can use =savehist= to populate these variables and
   additionally persist this "history" in a file.

   The target directory here is going to be called =cache= in lack of
   a better name.

   Hence, our code here is going to:

   1. "Create if it doesn't exist" the =~/.emacs.d/cache= directory;
   2. Configure some settings from =savehist=;
   3. Enable =savehist mode=.


   #+BEGIN_SRC emacs-lisp

   (let ((cache-dir (expand-file-name "cache/" user-emacs-directory)))
     (unless (file-exists-p cache-dir)
       (make-directory cache-dir)))

   #+END_SRC

   Now, configure =savehist=:

   #+BEGIN_SRC emacs-lisp

   ;; file name where minibuffer history is saved to and loaded from.
   (customize-set-variable
    'savehist-file (concat user-emacs-directory "cache/history"))

   ;; if non-nil, save all recorded minibuffer histories.
   (customize-set-variable 'savehist-save-minibuffer-history t)

   ;; maximum length of history lists before truncation takes place
   (customize-set-variable 'history-length 1024)

   #+END_SRC

   And finally, enable =savehist mode=:

   #+BEGIN_SRC emacs-lisp

   ;; enable savehist mode
   (add-hook 'window-setup-hook
             (lambda ()
               (funcall 'savehist-mode 1)))

   #+END_SRC

* Global Key Binds

  Here are some very useful general purpose keybinds for both
  navigating and editing buffers in Emacs.

  The depencies here are:
  1. handy-buffer.el (3rd party);
  2. browse-kill-ring.el (3rd party);
  3. simple.el;
  4. window.el;


  #+BEGIN_SRC emacs-lisp

  ;; line movement
  (global-set-key (kbd "C-a") 'handy-buffer/back-to-indent-or-line) ;; handy-buffer.el
  (global-set-key (kbd "C-e") 'move-end-of-line)

  ;; word movement
  (global-set-key (kbd "C-<left>") 'backward-word)
  (global-set-key (kbd "C-<right>") 'forward-whitespace)

  ;; scroll movement
  (global-set-key (kbd "C-M-v") 'scroll-other-window)
  (global-set-key (kbd "C-M-y") 'scroll-other-window-down)

  ;; edit
  (global-set-key (kbd "M-y") 'browse-kill-ring) ;; browse-kill-ring.el
  (global-set-key (kbd "M-i") 'handy-buffer/indent-region-or-buffer) ;; handy-buffer.el
  (global-set-key (kbd "M-j") 'handy-buffer/duplicate-line-or-region) ;; handy-buffer.el
  (global-set-key (kbd "M-n") 'handy-buffer/transpose-lines-up) ;; handy-buffer.el
  (global-set-key (kbd "M-p") 'handy-buffer/transpose-lines-down) ;; handy-buffer.el
  (global-set-key (kbd "M-l") 'downcase-word)
  (global-set-key (kbd "C-w") 'handy-buffer/kill-region-or-backward-word) ;; handy-buffer.el

  ;; search
  (global-set-key (kbd "M-s M-o") 'handy-buffer/list-occurrences-at-point) ;; handy-buffer

  ;; kill
  (define-key ctl-x-map (kbd "k") 'kill-buffer)

  ;; keyboard quit. might remove this. not really used.
  (global-set-key (kbd "M-ESC") 'keyboard-escape-quit)

  ;; in buffer completion
  ;; (global-set-key (kbd "C-M-i") 'complete-or-indent)

  #+END_SRC

* Dealing with Directories (dired)

  =dired= is the main tool for dealing with directories inside Emacs.
  Here are some really minor tweaks for an improved usage.

  Avoid creating a bunch of buffers from the directories accessed from
  =dired=:

  #+BEGIN_SRC emacs-lisp

  ;; enable dired-find-alternate-file
  (add-hook 'window-setup-hook
            (lambda ()
              (put 'dired-find-alternate-file 'disabled nil)))

  #+END_SRC

  And add some key-binds to improve usability:

  #+BEGIN_SRC emacs-lisp

  ;; dired-mode-map
  (eval-after-load 'dired
    (lambda ()
      (when (boundp 'dired-mode-map)
        (define-key dired-mode-map (kbd "RET") 'dired-find-alternate-file)
        (define-key dired-mode-map (kbd "C-j") 'dired-find-alternate-file))))

  #+END_SRC

* Dealing with Buffers

  This is a large (and probably chaotic) section for everything we
  consider to be "dealing with buffers". Hence, there might be some
  functions and variables mentioned here that are =technically=
  "dealing with windows", however, since the "side effects feel like"
  they're being applied to the buffer being displayed, we'll keep
  these functions and variables here.

** Manipulating Buffers

   #+BEGIN_SRC emacs-lisp

   ;; kill buffer and window
   (define-key ctl-x-map (kbd "C-k") 'kill-buffer-and-window)

   #+END_SRC

** Editing Buffers

** Navigating through Buffers

   Here are some general purpose binds/commands for navigating through
   buffers.

   #+BEGIN_SRC emacs-lisp

   ;; next and previous buffer (on current window)
   (define-key ctl-x-map (kbd "C-,") 'previous-buffer)
   (define-key ctl-x-map (kbd "C-.") 'next-buffer)

   #+END_SRC

   The following are specific libraries/subsections related to buffer
   navigation.

*** Ibuffer

    Ibuffer is a major mode for viewing buffers arranged as a list.
    This lib provides a convenient way of performing many operations
    on opened buffers as well as many ways of manipulating the
    arranged list, i.e., filtering subsets of list elements,
    aggregating related buffers, etc.

    #+BEGIN_SRC emacs-lisp

    ;; the criteria by which to sort the buffers
    (customize-set-variable 'ibuffer-default-sorting-mode 'filename/process)

    ;; if non-nil, display the current Ibuffer buffer itself
    (customize-set-variable 'ibuffer-view-ibuffer nil)

    ;; if non-nil, then show the names of filter groups which are empty
    (customize-set-variable 'ibuffer-show-empty-filter-groups nil)

    #+END_SRC

    As mentioned, Ibuffer accepts an association list as instruction
    on how to filter/separate displayed opened buffers.

    #+BEGIN_SRC emacs-lisp

    (customize-set-variable
     'ibuffer-saved-filter-groups
     (quote (("default"
              ("Emacs" (or
                        (name . "^\\*eldoc for")
                        (name . "^\\*scratch\\*$")
                        (name . "^\\*Warnings\\*$")
                        (name . "^\\*Completions\\*$")
                        (name . "^\\*Completions\\*$")
                        (name . "^\\*Messages\\*$")))

              ("Comint" (or
                         (mode . comint-mode)
                         (name . "^\\*dashboard\\*$")
                         (name . "^\\*tramp")
                         (name . "^\\*make\\*$")))

              ("Custom" (mode . Custom-mode))

              ("Info"  (or
                        (mode . Info-mode)
                        (mode . dictionary-mode)
                        (mode . help-mode)
                        (mode . apropos-mode)
                        (mode . Man-mode)))

              ("Tags" (or
                       (mode . tags-table-mode)
                       (mode . xref--xref-buffer-mode)))

              ("Compilation" (or
                              (mode . compilation-mode)
                              (mode . emacs-lisp-compilation-mode)
                              (name . "^\\*compilation\\*$")))

              ("Debug"  (or (mode . debugger-mode)
                            (name . "^\\*debug")))

              ("Org" (or (mode . org-mode)
                         (name . "\\.org")))

              ("Grep" (or
                       (mode . ag-mode)
                       (mode . occur-mode)))

              ("Term" (mode . term-mode))
              ("Shell" (or
                        (mode . shell-mode)
                        (mode . eshell-mode)))

              ("Eww" (mode . eww-mode))
              ("Dired" (mode . dired-mode))

              ("Magit" (or
                        (mode . magit-mode)
                        (mode . magit-status-mode)
                        (mode . magit-diff-mode)
                        (mode . magit-process-mode)))))))

    #+END_SRC

    Now, let's add a some calls to =ibuffer-mode-hook= to tell it how
    to behave upon its entry:

    #+BEGIN_SRC emacs-lisp

    ;; hook run upon entry into `ibuffer-mode'
    (add-hook 'ibuffer-mode-hook
              (lambda ()
                (ibuffer-auto-mode 1)
                (ibuffer-switch-to-saved-filter-groups "default")))

    #+END_SRC

    And, ~finally~, let's add a key bind so we can quickly call it:

    #+BEGIN_SRC emacs-lisp

    (define-key ctl-x-map (kbd "C-b") 'ibuffer)

    #+END_SRC

** Navigating inside Buffers

* Dealing with Windows
* Project Management

  We'll use two libraries for project management and this choice
  assumes we use =git= for the majority our projects.

** Projectile

   Might not be needed. Emacs has a =project= library at its core now,
   that has basically all projectile features we need.

* Version Control (magit)

  /Note: Please refer to [[https://magit.vc/manual/magit/Installing-from-the-Git-Repository.html][this manual]] for Magit's installation and/
  /proper =loaddefs= generation./

  Magit is a true git porcelain. So, we're simply going to bind a key
  to invoke Magit from a project:

  #+BEGIN_SRC emacs-lisp

  (define-key ctl-x-map (kbd "j") 'magit-status)

  #+END_SRC

  Magit has a couple of external denpencies:

  - =compat=, =dash=, =transient= and =with-editor=.

  And adding the following key-binds to =text-mode-map= is useful when
  editing commit messages.

  #+BEGIN_SRC emacs-lisp

  (define-key text-mode-map (kbd "C-c C-k") 'with-editor-cancel)
  (define-key text-mode-map (kbd "C-c C-c") 'with-editor-finish)

  #+END_SRC

* Org Mode

  #+BEGIN_QUOTE
  Org Mode is an authoring tool and a TODO lists manager for GNU Emacs.
  It relies on a lightweight plain-text markup language used in files with
  the ‘.org’ extension.
  #+END_QUOTE

  Org is amazing and makes so many things (like this configuration
  file) possible.

  Here are some simple configurations:

  #+BEGIN_SRC emacs-lisp

  ;; when non-nil, fontify code in code blocks
  (customize-set-variable 'org-src-fontify-natively t)

  ;; if non-nil, the effect of TAB in a code block is as if it were
  ;; issued in the language major mode buffer
  (customize-set-variable 'org-src-tab-acts-natively t)

  ;; indentation for the content of a source code block.
  (customize-set-variable 'org-edit-src-content-indentation 0)

  ;; confirm before evaluation
  (customize-set-variable 'org-confirm-babel-evaluate t)

  ;; how the source code edit buffer should be displayed
  (customize-set-variable 'org-src-window-setup 'current-window)

  ;; non-nil means C-a and C-e behave specially in headlines and items
  (customize-set-variable 'org-special-ctrl-a/e t)

  ;; non-nil means adapt indentation to outline node level.
  ;; important: without this org messes up the file indentation.
  (customize-set-variable 'org-adapt-indentation t)

  #+END_SRC

  And, as seen in this file, Org allows for code block
  execution/evaluation and to inform Org of the languages we wish to
  use, we have to add entries to the =org-babel-load-languages=
  variable:

  #+BEGIN_SRC emacs-lisp

  (add-hook 'org-mode-hook
            (lambda ()
              ;; do not truncate lines
              (setq truncate-lines nil)

              ;; languages which can be evaluated in Org buffers.
              (org-babel-do-load-languages
               'org-babel-load-languages
               '((emacs-lisp . t)
                 (shell . t)
                 (python . t)))))

  #+END_SRC

* Customizations

  Disabling all "bars" in order to have a "clean screen":

  #+BEGIN_SRC emacs-lisp

  (custom-set-variables
   '(menu-bar-mode nil)
   '(scroll-bar-mode nil)
   '(tool-bar-mode nil))

  #+END_SRC

* What's missing
** DONE Finish Custom Lex library

   For now, only =lex-buffer.el= is required;
   This is now called =handy-buffer.el= and it's available at:
   https://github.com/yagossc/el-handy/

** TODO Check other Lex dependencies
** DONE Lazy loading

   Adapt to new el-lazy.

   I actually preferred creating a simple function to manually deal
   with this.

** TODO Git submodules

   Organize third party libraries as git submodules forked in my own
   github.

** TODO Install script

   This should contain the following:

*** DONE Create if doesn't exist: "~/.emacs.d" symbolic link

    #+BEGIN_SRC sh

    _src_dir=$(pwd)

    echo $_src_dir

    if [ -e ~/.emacs.d ]
    then
        echo "[INFO] ~/.emacs.d symbolic link already exists"
    else
        ln -s $_src_dir ~/.emacs.d
    fi

    #+END_SRC

*** DONE Create if doesn't exist: ~/.emacs.d/lisp

    #+BEGIN_SRC sh

    if [ -e ~/.emacs.d/lisp ]
    then
        echo "[INFO] ~/.emacs.d/lisp dir already exists"
    else
        mkdir ~/.emacs.d/lisp
    fi

    #+END_SRC

*** TODO Create if doesn't exist: ~/.emacs.d/lisp/subdirs.el

    It might make more sense for this to be part of the =init.el= and
    not an =install.sh= script.

** TODO Create needed sections

   As of now, it seems to make sense to have the 3 sections:
   - Frames;
   - Windows;
   - Buffers;

   And add to them all the global "generic" configurations (hooks,
   macros, variable customizations, etc.

   Also maybe a "Display" or "Screen" section for things like the
   menubar, highlight line, etc.

** TODO Theme

   - Fiddle with darcula theme until good enough;
   - Remove unused customizations;

** TODO Minibuffer

   This takes its own section

** TODO Custom file

   The =custom.el= is a good place for calls like

   #+BEGIN_SRC emacs-lisp :tangle no

   (safe-funcall 'menu-bar-mode 0)

   #+END_SRC

** TODO Completion

   This could get its own section

** TODO Terminals

   This could get its own section

** DONE Org mode

   This could get its own section

** TODO Documentation

   Here there could be configurations for =man=, =woman= and
   =dash-docs=.

*** TODO Dash Docs for

** TODO Project Management

   Here goes magit and projectile and that's it.

*** DONE Magit
*** TODO Projectile

** TODO Programming

   Here goes the editing code specifics.

*** TODO General
*** TODO Language Specific

** TODO Cleanup

   For removing key-binds from minor modes, etc.
